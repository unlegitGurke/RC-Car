\subsection{Kern 0 / Sensoren und Kommunikation}
	Die Hauptaufgabe von Kern 0 ist es, mit dem Bordcomputer zu kommuniziern, alle Sensordaten auszulesen, und Komponenten, wie zum Beispiel Lüfter, zu steuern.
	Die Seriellen Schnittstellen vom ESP32 und dem Bordcomputer sind mithilfe des Shields verbunden, um eine flüssige Kommunikation zu gewährleisten, ist ein Protokoll nötig:
	
	\subsubsection{Aufbau von Paketen zwischen ESP32 und Bordcomputer}
		Der grundsätzliche Aufbau eines Paktes zwischen ESP32 und Bordcomputer ist immer gleich, er besteht aus folgenden Teilen
			
			\begin{enumerate}
			
				\item Datentyp: LED, Temp, Volt, IMU1, IMU2, Sonar, FAN, Error //Alle möglichen Daten, die zwischen ESP und Bordcomputer gesendet werden können. 
				
				\item Anzahl der Datenwerte
				
				\item Access, Read / Write / Both  //Sollen die Daten nur eingelesen werden, wird nur eine Antwort erwartet oder wird beides erwartet?
				
				\item Daten, je nach Anzahl der Datenwerte können hier beliebig viele Werte hintereinander geschrieben werden
				
				\item Error, wird ein Fehler gemeldet?
			
			\end{enumerate}
			
			Jedes Datenpaket beginnt mit einem Marker und endet mit einem Marker, in diesem Fall wurde als StartMarker "x" verwendet und als EndMarker "y". Die Daten sind in dazwischen in genannter Reihenfolge mit Beistrichen getrennt.
			Die Größe der verschiedenen Datenpaktet ist wiefolgt:
			
			\begin{table}[H]
				\centering
				\caption{Datenpakete}
				
				\begin{tabular}{|c|c|c|c|c|c|}
					
					\hline
					\multicolumn{6}{|c|}{\textbf{Datenpakete}}\\
					\hline
					\hline
					\textbf{Name} & \textbf{Datentyp} & \textbf{Anzahl der Variablen} & \textbf{Access} & \textbf{Daten} & \textbf{Error} \\
					\hline
					IMU1 & 1 & 6 & 1 & - & 0 \\
					\hline
					IMU2 & 2 & 3 & 1 & - & 0 \\
					\hline
					OctoSonar & 3 & 16 & 1 & - & 0 \\
					\hline
					Spannungssensoren & 4 & 5 & 1 & - & 0 \\
					\hline
					Temperatursensoren & 5 & 6 & 1 & - & 0 \\
					\hline
					Lüfter & 6 & 4 & 2 & - & 0 \\
					\hline
					LEDs & 7 & 4 & 2 & - & 0 \\
					\hline
					IsOK & 0 & 0 & 2 & - & 0 \\
					\hline
					
				\end{tabular}
			\end{table}
			
			Access = 0 bedeutet, dass Daten nur vom ESP gelesen werden und es keine Antwort gibt.\\
			Access = 1 bedeutet, dass Daten an den Bordcomputer vom ESP geschickt werden sollen.\\
			Access = 2 bedeutet, dass Daten vom ESP eingelesen werden sollen und dass eine Antwort geschickt werden soll.\\
			\\
			Error = 0 bedeutet, das kein Fehler vorhanden ist.\\
			Error = 1 bedeutet, dass eine Warnung vorhanden ist.\\
			Error = 2 bedeutet, dass ein fataler Fehler vorhanden ist.\\
			
		\subsubsection{Einlesen der Pakete am ESP32}
			Für die Kommunikation zwischen ESP32 und Bordcomputer ist eine eigene Bibliothek verantwortlich, so muss im Hauptprogramm nur eine Objekt "Computer" erstellt werden, um Daten einzulesen beziehungsweise zu empfangen.
			Die erste Funktion der Bilbiothek ließt die Daten ein und speichert sie in einem Buffer:
			
			\lstset{style=VS2017}
			\begin{lstlisting}[language=C, caption={Einlesen eines Pakets}]
bool LattePandacomms::refresh(char startMarker, char endMarker) {
  
  _inProgress = false;
  
  while (Serial.available() > 0) {    //Checks for Serial Data
    
    byte x = Serial.read();   //Reads Serial Data
    
    if (x == startMarker && _inProgress == false) {    //First Byte = startMarker?
       
      _bytesRecvd = 0;      //Zero bytes have been recieved so far
      _inProgress = true;   //New Message has started
      
      for(int i = 0; i < sizeof(BufferIn); i++) {   //Clear BufferIn Array
        BufferIn[i] = '\0';
      }
      
    }
    
    if (_inProgress ) {   //Has the message started?
          
      if (_bytesRecvd<_maxMessage) {    //Max message limit?
        
        BufferIn[_bytesRecvd++] = x;  //Save current Byte to Buffer
        
      }
      
      if (x == endMarker) {     //End of message 
        
        _inProgress = false;    //Reset inprogress variable
        //allReceived = true;
        _nb = _bytesRecvd;
        return 1;
        
      }
      
    }

    
  }
  
  //Serial.println(BufferIn);   //DEBUG
  return 0;
  
}			
			\end{lstlisting}
			
			Diese Funktion wartet auf den StartMarker und speichert anschließend bis zum Erscheinen des EndMarkers jede Ziffer in ein Buffer-Array, welches danach weiterverarbeitet werden kann.
			
			\subsubsection{Dekodieren der Pakete am ESP32}
					Um das sich im Buffer befindliche Paket nun zu dekodieren sind zwei zusätzliche Funktionen nötig:\\
					Die Funktion \textit{bool removeMarkers()} entfernt den Start-und Endmarker, da diese nicht dekodiert werden müssen.\\
					
					\lstset{style=VS2017}
					\begin{lstlisting}[language=C, caption={RemoveMarkers()}]
bool removeMarkers(char* inputMessage,
                   char* outputMessage, 
                   char startMarker, 
                   char endMarker) {   
  
  int startIndex = 0;
  int endIndex = 0;

  for (int i = 0; i < strlen(inputMessage); i++) {
      if (inputMessage[i] == startMarker) {
        startIndex = i + 1;     // Skip startMarker
      } 
      else if (inputMessage[i] == endMarker) {
         endIndex = i;
         break;    // Stop once endMarker is found
      }
  }
  
	// Extract the substring between startMarker and endMarker into the output message
  if (endIndex > startIndex) {    
    strncpy(outputMessage, inputMessage + startIndex, endIndex - startIndex);
    outputMessage[endIndex - startIndex] = '\0';    // Null-terminate the output message
    return true;
  } 
  
  else {
    outputMessage[0] = '\0'; // Empty output message if 'q' is not found after 'x'
    return false;
  }  
  
}					
					\end{lstlisting}
					
					Mithilfe von der Funktion \textit{bool removeFirstValue()} ist möglich den ersten Wert aus einem Char-Array zu löschen. So kann nun immer der erste Wert eingelesen werden und dann gelöscht werden. Dies wird so oft widerholt, bis die gewünschte Anzahl an Variablen(durch Anzahl der Variablen im Paket gegeben) eingelesen ist.\\
					
					\lstset{style=VS2017}
					\begin{lstlisting}[language=C, caption={RemoveMarkers()}]
bool removeFirstValue(char* inputMessage, char* outputMessage) { 
    
  int commaIndex = 0;
  
	//Search for first comma
  while (inputMessage[commaIndex] != ',' && inputMessage[commaIndex] != '\0') {   
    commaIndex++;
  }
  
	// If comma is found, copy the substring after first comma into output message
  if (inputMessage[commaIndex] == ',') {    
    strcpy(outputMessage, inputMessage + commaIndex + 1);
    return true;
  } 
  
  else {
    return false;
  }
  
}					
					\end{lstlisting}
					
					Diese eingelesen Variablen werden in Komponenten, die durch ein struct definiert sind, im public Teil der Class abgespeichert, so ist es möglich vom Hauptcode auf diese zuzugreifen:
					
					\lstset{style=VS2017}
					\begin{lstlisting}[language=C, caption={Datenspeicherort und Struktur}]
struct Component {    //Struktur des Datenspeicherorts
  uint8_t Type;
  uint8_t nVal;
  uint8_t Access;
  uint8_t Data[maxnDataVar];
  uint8_t Error;
};

class LattePandacomms {
public:
  
  LattePandacomms();

  Component IsOk;		//Datenspeicher der einzelnen Komponenten
  Component IMU1;
  Component IMU2;
  Component Octosonar;
  Component Voltage;
  Component Temp;
  Component Fan;
  Component LED;
}						
					\end{lstlisting}
					
					Im Hauptprogramm können Daten eingelesen werden indem sie durch das Objekt aufgerufen werden (zum Beispiel: Objekt.IMU1.Data[1];).
			\subsubsection{Einlesen der Sensordaten}
					
					Zusätzlich zur Kommunikation liest Kern 0 auch alle Sensordaten ein und steuert alle Lüfter. Die Funktionen sind essenziell sehr ähnlich aufgebaut. Es werden zuerst die Werte (meist mithilfe von einer Bibliothek) eingelesen und anschließend in das Kommunikationsobjekt gespeichert, oder wie im Fall der Lüfter, aus dem Objekt ausgelesen und übernommen. Der Intervall indem Daten ausgelesen werden, kann außerdem für alle Sensoren festgelegt werden.
					
					\lstset{style=VS2017}
					\begin{lstlisting}[language=C, caption={Einlesen der Spannungssensoren}]	
void VoltageSensor() {
  
  currentMillisVoltage = millis();
  if(currentMillisVoltage - previousMillisVoltage >= ReadIntervallVoltage) {
    previousMillisVoltage = currentMillisVoltage;

    for(int i = 0;i < NOSVoltage;i++) {                         
      float value = analogRead(VoltagePin[i]);          //Reads all the AnalogPins Values
			
      //Calculates the voltages from the sensorpins values
      LattePanda.Voltage.Data[i] = value*(LogicLevel/pow(2, ADCRes))*((R1[i] + R2[i])/R2[i]);    
    }
    
  }
}					
					\end{lstlisting}
					
					\lstset{style=VS2017}
					\begin{lstlisting}[language=C, caption={Steuern der Lüfter}]	
void Fan_Control() {

  for(int i = 0;i < 4;i++) {
    
    FanSpeed[i] = LattePanda.Fan.Data[i];   //Read Data from LattePanda
		
    //Calculate DutyCycle from Speed Value 
    DutyCycle[i] = map(FanSpeed[i], 0, 100, 0, pow(2, Resolution[i]));    

    ledcWrite(PWMChannel[i], DutyCycle[i]);     //Write PWM Signal to Pins

  }

}					
					\end{lstlisting}
					Die Loop-Schleife von Kern 0 ruft dauerhaft folgende Funktionen auf:
					
					\lstset{style=VS2017}
					\begin{lstlisting}[language=C, caption={Steuern der Lüfter}]	
void Task1loop() {
  
  CheckError();
  ReadTemp();
  ReadSonar();
  ReadIMU();
  Fan_Control();
  VoltageSensor();
  getSerialData();
	SendSerialData();

  delay(1);

}					
					\end{lstlisting}
					